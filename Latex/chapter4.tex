%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Szablon pracy dyplomowej
% Wydział Informatyki 
% Zachodniopomorski Uniwersytet Technologiczny w Szczecinie
% autor Joanna Kołodziejczyk (jkolodziejczyk@zut.edu.pl)
% Bardzo wczesnym pierwowzorem szablonu był
% The Legrand Orange Book
% Version 5.0 (29/05/2025)
%
% Modifications to LOB assigned by %JK
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%----------------------------------------------------------------------------------------
%	CHAPTER 4
%----------------------------------------------------------------------------------------
\sloppy

\lstdefinestyle{csharp}{
	language=[Sharp]C,
	basicstyle=\ttfamily\small,
	keywordstyle=\color{blue},
	stringstyle=\color{red},
	commentstyle=\color{gray},
	numbers=left,
	numberstyle=\tiny,
	stepnumber=1,
	numbersep=5pt,
	frame=single,
	breaklines=true,
	captionpos=b,
	showtabs=false
}
\lstdefinelanguage{TypeScript}{
	language=JavaScript,
	morekeywords={interface, type, implements, readonly, public, private, protected, enum, as, unknown, never},
	sensitive=true
}

\lstdefinestyle{tsstyle}{
	language=TypeScript,
	basicstyle=\ttfamily\small,
	keywordstyle=\color{blue},
	stringstyle=\color{red},
	commentstyle=\color{gray},
	numbers=left,
	numberstyle=\tiny,
	stepnumber=1,
	numbersep=5pt,
	frame=single,
	breaklines=true,
	tabsize=2,
	showtabs=false,
	showstringspaces=false
}

\chapter{Implementacja}
\label{rozdzial4}

\section{Środowisko i narzędzia programistyczne}
\index{Środowisko i narzędzia programistyczne}

\subsection{Zintegrowane środowisko programistyczne (IDE)}
\index{Zintegrowane środowisko programistyczne (IDE)}

Do pracy nad systemem wykorzystywane są narzędzia firmy JetBrains. Jetbrains IDE\footnote{Zintegrowane środowisko programistyczne, IDE – program lub zespół programów służących do tworzenia, modyfikowania, testowania i konserwacji oprogramowania.\cite{wikipedia.pl}} WebStorm dla prac Frontendowych Angular oraz IDE Rider do pracy z kodem C\# i Asp.Net Core. Są to zaawansowane narzędzia developerskie zapewniające kompleksowe wsparcie dla wybranych technologii.

\subsection{Narzędzia wspomagające rozwój oprogramowania}
\index{Narzędzia wspomagające rozwój oprogramowania}

Do śledzenia zmian kodu, wersjonowania oraz dla bezpieczeństwa projekt kod i wszystkie niezbędne pliki są przechowywane w systemie Git. Repozytorium Git\footnote{Git to rozproszony system kontroli wersji stworzony przez Linus'a Torvalds'a. Jest to aktualnie najczęściej wykorzystywane narzędzie do wersjonowania kodu na świecie, zarówno wśród hobbystów i pasjonatów programowania jak i w środowiskach profesjonalnych i biznesach.} znajduję się w serwisie Github\footnote{https://github.com/}.

\subsection{Środowisko uruchomieniowe i infrastruktura}
\index{Środowisko uruchomieniowe i infrastruktura}

\subsubsection{Maszyna deweloperska}
Konfiguracja maszyny deweloperskiej jest następująca:
\begin{itemize}
	\item \textbf{System operacyjny} - Windows 11
	\item \textbf{Serwer web} - Microsoft IIS oraz Node.js
	\item \textbf{Środowisko .NET} - .NET Core SDK 8.0.15
	\item \textbf{Środowisko Node.js} - Node v22 LTS
	\item \textbf{IDE} - JetBrains Rider 2024.3.* oraz JetBrains WebStorm 2024.3.6
\end{itemize}

\subsubsection{Serwer produkcyjny}
\begin{itemize}
	\item \textbf{System operacyjny} - Ubuntu 24.04 LTS
	\item \textbf{Serwer web} - Nginx oraz Node.js
	\item \textbf{Środowisko .NET} - .NET Core Runtime 8.0.15
	\item \textbf{Środowisko Node.js} - Node v22 LTS
\end{itemize}

\section{Struktura projektu}
\index{Struktura projektu}

Projekt został logicznie podzielony na dwie części. Pierwsza część frontendowa w technologii Angular z wykorzystaniem środowiska Node.js oraz npm. Drugą cześć to backend ASP.NET Core wraz z bazą danych SQLite3 wykorzystujące platformę .NET Core.

\subsection{Struktura folderów}
\index{Struktura folderów}

\subsubsection{Frontend}
Poniżej została przedstawiona struktura projektu Angular:
\begin{itemize}
	\item \textbf{public} - znajdują się w nim stałe grafiki strony
	\item \textbf{src} - katalog z kodem źródłowym aplikacji wraz z plikami index.html, main.ts oraz styles.scss
		\begin{itemize}
			\item \textbf{app} - kody źródłowe z podziałem na kolejne katalogi oraz głównym componentem applikacji i konfiguracją route
				\begin{itemize}
					\item \textbf{components} - komponenty składające się z kodu .ts oraz szablonu .html wykorzystywane wielokrotnie w aplikacji
					\item \textbf{interceptors}
					\item \textbf{models} - klasy wykorzystywane do przechowywania danych pobieranych z backendu
					\item \textbf{pages} - komponenty .ts i szablony .html tworzące strony, dialogi oraz formularze poszczególnych funkcjonalności serwisu
					\item \textbf{services} - serwisy wykorzystywane do autoryzacji i komunikacji z backendem
				\end{itemize}
			\item \textbf{environments} - pliki z danymi konfiguracyjnymi dla środowiska deweloperskiego i produkcyjnego
		\end{itemize}
\end{itemize}

\subsubsection{Backend}
Poniżej wylistowano strukturę projektu ASP.NET Core:
\begin{itemize}
	\item \textbf{Constants} - klasy ze stałymi wykorzystywane w projekcie
	\item \textbf{Controllers} - kontrolery REST API
	\item \textbf{Data} - kontekst bazodanowy oraz klasa obsługująca tworzenie nowej bazy z podstawową zawartością
	\item \textbf{Interfaces} - pliki interfejsów C\# implementowanych w aplikacji
	\item \textbf{Migrations} - migracje SQL tworzone przy modyfikacji modelów danych C\# i wykorzystywane do tworzenia i aktualizacji struktury bazy danych
	\item \textbf{Models} - modele danych w postaci klas C\# wykorzystywane w bazie danych oraz w komunikacji z Frontendem
		\begin{itemize}
			\item \textbf{DTOs} - uproszczone modele danych wykorzystywane w komunikacji z Frontendem
		\end{itemize}
	\item \textbf{Properties} - pliki konfiguracyjne uruchamiania
	\item \textbf{Services} - serwisy służące do autoryzacji i komunikacji z bazą danych
	\item \textbf{wwwroot} - folder zawierający przesyłane obrazy do aplikacji, dostępny z poziomu frontendu
\end{itemize}

\subsection{Technologie i zależności}
\index{Technologie i zależności}

\subsubsection{REST API}
W projekcie wymiana danych pomiędzy frontendem i backendem odbywa się za pomocą REST API, a dane są serializowane/deserializowane w standardzie JSON\footnote{JSON to skrót od JavaScript Object Notation (JavaScript Object Notation) JSON to lekki format do przechowywania i transportu danych. Z ang. \cite{w3s_json}}.

\begin{lstlisting}[style=tsstyle, caption=Przykład danych w formacie JSON]
{
"employees":[
	{"firstName":"John", "lastName":"Doe"},
	{"firstName":"Anna", "lastName":"Smith"},
	{"firstName":"Peter", "lastName":"Jones"}
]
}
\end{lstlisting}

\begin{lstlisting}[style=csharp, caption=Fragment kontrolera REST API z projektu]
namespace BackendService.Controllers
{
	[ApiController]
	[Route("api/[controller]")]
	public class BirdsController : ControllerBase
	{
		private readonly ApplicationDbContext _context;
		private readonly IBirdService _birdService;

		public BirdsController(ApplicationDbContext context, IBirdService birdService)
		{
			_context = context;
			_birdService = birdService;
		}

		[HttpGet]
		public async Task<ActionResult<PaginatedResponse<Bird>>> GetBirds([FromQuery] PaginationParams paginationParams)
		{
			var birds = await _birdService.GetAllBirdsAsync(paginationParams);
			return Ok(birds);
		}
...
\end{lstlisting}

\begin{lstlisting}[style=tsstyle, caption=Fragment serwisu po stronie frontendu]
@Injectable({
	providedIn: 'root'
})
export class BirdService {
	private baseUrl = `${environment.api.baseUrl}
		${environment.api.endpoints.birds}`;
	
	constructor(
	private http: HttpClient,
	private router: Router
	) { }
	
	private handleError(error: HttpErrorResponse) {
		if (error.status === 401 || error.status === 403) {
			// Przekieruj do strony logowania
			this.router.navigate(['/login'], { 
				queryParams: { 
					returnUrl: this.router.url 
				}
			});
		}
		return throwError(() => error);
	}
	
	getAllBirds(paginationParams: PaginationParams): Observable<PaginatedResponse<Bird>> {
		const params = new HttpParams()
		.set('pageNumber', paginationParams.pageNumber.toString())
		.set('pageSize', paginationParams.pageSize.toString());
		return this.http.get<PaginatedResponse<Bird>>(
			this.baseUrl, { params })
		.pipe(catchError(this.handleError.bind(this)));
	}
...
\end{lstlisting}

\subsubsection{ORM}
Do mapowania obiektowo-relacyjnego wykorzystywany jest Entity Framework Core. Umożliwia on pracę na platformie .NET z bazami danych przy użyciu kontekstu oraz modeli danych. Wykonywanie zapytań bazodanowych odbywa się w tle a programistą udostępniony jest wygodny interfejs LINQ\footnote{Zapytanie zintegrowane z językiem (LINQ) - zestaw technologii opartych na integracji funkcji zapytań bezpośrednio w języku C\#\cite{dotnet_linq}} niewymagający ręcznego pisania zapytań.

Przykład takiego wywołania zapytań został przedstawiony poniżej:
\begin{lstlisting}[style=csharp, caption=Przykład wywołania zapytania bazodanowego za pomocą EF Core oraz LINQ]
var query = _context.Birds.Where(b =>
	b.IsVerified && (
	b.CommonName.ToLower().Contains(searchTerm) ||
	b.ScientificName.ToLower().Contains(searchTerm) ||
	b.Family.ToLower().Contains(searchTerm) ||
	b.Description.ToLower().Contains(searchTerm)
	)
);
\end{lstlisting}

\section{Implementacja frontendu}
\index{Implementacja frontendu}

\section{Implementacja backendu}
\index{Implementacja backendu}

\section{Implementacja bazy danych}
\index{Implementacja bazy danych}

\section{Implementacja systemu autentyfikacji i autoryzacji}
\index{Implementacja systemu autentyfikacji i autoryzacji}

\section{Implementacja funkcjonalności mapy i geolokalizacji}
\index{Implementacja funkcjonalności mapy i geolokalizacji}